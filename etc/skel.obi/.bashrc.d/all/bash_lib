#!/bin/bash
# vim:filetype=sh foldmethod=marker foldmarker="{{{,}}}"
# set -o vi

### colors #######################################################{{{
# set colors
_i=0
for _c in _black _red _green _yellow _blue _magenta _cyan _white; do
  printf -v "$_c" %s "$(tput setaf "$_i")"
  ((_i++))
done
unset _i _c

_bold=$(tput bold)
_reset=$(tput sgr0)

export _black _red _green _yellow _blue _magenta _cyan _white _bold _reset
### colors - end #################################################{{{

### array ########################################################{{{
#http://stackoverflow.com/questions/7442417/how-to-sort-an-array-in-bash
declare BSORT=()
_o_bubble_sort()
{
    # @param [ARGUMENTS]...
    #
    # Sort all positional arguments and store them in global array BSORT.
    # Without arguments sort this array. Return the number of iterations made.
    #
    # Bubble sorting lets the heaviest element sink to the bottom.
    #
    # @usage
    #
    # BSORT=(a c b 'z y' 3 5)
    # bubble_sort
    # echo ${BSORT[@]}
    (($# > 0)) && BSORT=("$@")
    local j=0 ubound=$((${#BSORT[*]} - 1))
    while ((ubound > 0))
    do
        local i=0
        while ((i < ubound))
        do
            if [ "${BSORT[$i]}" \> "${BSORT[$((i + 1))]}" ]
            then
                local t="${BSORT[$i]}"
                BSORT[$i]="${BSORT[$((i + 1))]}"
                BSORT[$((i + 1))]="$t"
            fi
            ((++i))
        done
        ((++j))
        ((--ubound))
    done
    echo $j
}
export BSORT _o_bubble_sort
### array - end ##################################################}}}

### formatted output #############################################{{{
_o_echo_padd(){
    local len="$1"
    local padd="$2"
    local args=
    shift 2
    ## get aditional arguments
    while : ; do
        if [[ $1 == @(-n|-e|-ne) ]]; then
            args+=$1
            shift
        else
            break
        fi
    done

    msg="$@ "
    #fill with padd
    while (( ${#msg} < len-1 )); do
        msg+="$padd"
    done
    msg+=" "
    #print
    echo $args "$msg"
}

_o_echo_long(){
    # breaks a long line in single lines that fit width
    # if the first argument is -f the second is inseted
    # in the beginning of the lines

    local fill=""
    if [[ "$1" == "-f" ]]; then
        fill="$2"
        shift 2
    fi
    # break output at width
    local line_out="$fill"
    local width=80
    for item in $@; do
        if (( (${#line_out} + ${#item})  > width )); then
            echo -ne "${line_out}\n"
            line_out="${fill}"
        else
            line_out+="$item "
        fi
    done
    echo -ne "${line_out}\n"
}

_o_section(){
    local fill_symbol="-"
    local title="$@"

    local width=80
    local fill=$(( width-${#title} ))
    local rest=$(( fill % 2 ))
    fill=$(( fill / 2))
    #printf "$fill_symbol%.0s" {1..$(( fill + rem ))}  - fuck no
    for (( n=1 ; n <= fill ; n++ )); do echo -n "$fill_symbol" ; done
    tput bold
    echo -n "$title"
    tput sgr0
    for (( n=1 ; n <= (fill+rest) ; n++ )); do echo -n "$fill_symbol" ; done
    echo
}

_o_write_x_n_times(){
    local ts=$(printf "%${2}s")
    printf %s ${ts// /$1}
}

_o_del_word(){
    cnt=0
    max=${#1}
    while (( cnt < max )); do
        echo -n -e "\b \b"
        (( cnt++ ))
    done
}

_o_exec_cmd(){
    echo "==============================================================================="
    echo "running: $@"
    echo "-------------------------------------------------------------------------------"
    $@
}
export _o_echo_padd _o_echo_long _o_section _o_exec_cmd _o_del_word _o_write_x_n_times
### formatted output - end #######################################}}}

### debug ########################################################{{{
export OBI_DEBUG=5
export OBI_DEBUG_ACTION='sleep'
_o_debug(){
    #
    # This function displays debug information
    # when the debug level set via command line
    # is greater or equal the level passed to
    # the function
    #
    # In:
    # $1 - level
    # $2 - message
    #
    ${conf[debug]} || return
    local action=""
    local level="$1"
    shift
    if [[ "$1" == @(ask|sleep) ]]; then
        action="$1"
        shift
    fi
    msg="$@"

    if (( level <= $OBI_DEBUG )); then
        while read -r debug_line <&13; do
            printf '%q\n' "debug $level: $debug_line" 1>&2
        done 13<<< "$msg"
    fi
    [[ "$OBI_DEBUG_ACTION" == "sleep" ]] && sleep 5
    [[ "$OBI_DEBUG_ACTION" == "ask" ]]   && read -p "press key to continue" -n 1
}
export _o_debug_
### debug end ####################################################}}}

### error ########################################################{{{
export OBI_ERROR_ACTION='ask'
_o_err(){ echo; echo -n "${_bold}${_red}Error: "; echo "${_white}$@${_reset}"; }

#fatal error
_o_ferr(){ _o_err "$@"; exit 1; }

#non fatal error
_o_nerr(){
_o_err "$@"
case $OBI_ERROR_ACTION in
    exit) exit 1 ;;
    ask)  local rv="$(_o_ask_yn "The Program encountered an error - do you want to continue?")"; [[ "$rv" == "no" ]] && exit 1 ;;
esac
}

# ask to continue on error
_o_ask_yn(){
while true; do
    read -p "$@ (y/n) " yn
    case "$yn" in
        [Yy]*) echo "yes"; break ;;
        [Nn]*) echo "no" ; break ;;
        *) echo "Please answer with yes or no." 1>&2 ;;
    esac
done
}

_o_ask_to_cont(){
    [[ $(_o_ask_yn "$1") == "yes" ]] || exit 1
}

export -f _o_err _o_nerr _o_ferr _o_ask_yn _o_ask_to_cont
### error - end ##################################################}}}

### fun ##########################################################{{{
_o_ssh_over_nodes(){
    # ssh connection over multipe hops
    local hosts=( "$@" )
    local hosts_len="${#hosts[@]}"
    local cmd="ssh ${hosts["$hosts_len"-1]}"
    for (( i=${#hosts[@]}-2; i>=0; i=i-1 )); do
        cmd="ssh -t ${hosts[$i]} $cmd"
    done
    $cmd
}

_o_countdown()
{
    local min=${1:-5}
    local sec=$((60 * min))
    local clear_eol=$(tput el)

    echo "countdown from $min:00 min "
    echo

    while (( sec > 0 )); do
        min_left=$((sec/60))

        if ((min_left >= 3)); then
            printf -v padded_sec "%02d" "$((sec%60))"
            out="$min_left:$padded_sec"
            unit=" min"
        else
            out="$sec"
            unit=" sec"
        fi

        tput bold
        tput setaf 1
        echo -n "     "
        echo -n "$out"
        tput sgr0
        echo -n "$unit"
        echo -n " left"

        sleep 1
        sec=$((sec - 1))

        #write_x_n_times $'\b' $((${#out}+${#unit}))
        echo -ne "\r$clear_eol"
    done
    echo
}
export _o_ssh_over_nodes _o_countdown
### fun - end ####################################################{{{

### system info ##################################################{{{
_o_udev_by_path(){
    udevadm info -a -p  $(udevadm info -q path -n $@)
}

_o_bugs(){
    # TODO - ask for bugs in smaller chunks

    # list bugs of given gravity
    local state=""
    if [[ -z $1 ]]; then
        state="$1"
    else
        state="serious"
    fi
    local pkg_list="$(dpkg -l | tail -n+5 | awk '{print $2}')"
    echo "pkg-list ### $pkg_list ###"
    apt-listbugs list -s "$state" $pkg_list | less
}
export _o_udev_by_path _o_bugs
### system info - end ############################################}}}
