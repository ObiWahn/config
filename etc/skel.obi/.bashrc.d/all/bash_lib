#!/bin/bash
# Copyright - 2010-2018 - Jan Christoph Uhde <Jan@UhdeJC.com>
# vim:filetype=sh foldmethod=marker foldmarker="{{{,}}}"
# set -o vi

### colors #######################################################{{{
# set colors
_i=0
for _c in _black _red _green _yellow _blue _magenta _cyan _white; do
  printf -v "$_c" %s "$(tput setaf "$_i")"
  ((_i++))
done
unset _i _c

_bold=$(tput bold)
_reset=$(tput sgr0)

export _black _red _green _yellow _blue _magenta _cyan _white _bold _reset
### colors - end #################################################{{{

### formatted output #############################################{{{
_o_symbol_section(){
    local fill_symbol="${1:-'-'}"; shift
    local title="$@"

    local width=80
    if [[ -n $title ]]; then
        width=$(( width -2 ))
    fi
    local fill=$(( width-${#title} ))
    local rest=$(( fill % 2 ))
    fill=$(( fill / 2))
    #printf "$fill_symbol%.0s" {1..$(( fill + rem ))}  - fuck no
    for (( n=1 ; n <= fill ; n++ )); do echo -n "$fill_symbol" ; done
    if [[ -n "$title" ]]; then
        echo -n " ${_bold}$title${_reset} "
    fi
    for (( n=1 ; n <= (fill+rest) ; n++ )); do echo -n "$fill_symbol" ; done
    echo
}

_o_section(){
    _o_symbol_section "-" "$@"
}

_o_echo_padd(){
    local len="$1"
    local padd="$2"
    local args=
    shift 2
    ## get aditional arguments
    while : ; do
        if [[ $1 == @(-n|-e|-ne) ]]; then
            args+=$1
            shift
        else
            break
        fi
    done

    msg="$@ "
    #fill with padd
    while (( ${#msg} < len-1 )); do
        msg+="$padd"
    done
    msg+=" "
    #print
    echo $args "$msg"
}

_o_echo_long(){
    # breaks a long line in single lines that fit width
    # if the first argument is -f the second is inseted
    # in the beginning of the lines

    local fill=""
    if [[ "$1" == "-f" ]]; then
        fill="$2"
        shift 2
    fi
    # break output at width
    local line_out="$fill"
    local width=80
    for item in $@; do
        if (( (${#line_out} + ${#item})  > width )); then
            echo -ne "${line_out}\n"
            line_out="${fill}"
        else
            line_out+="$item "
        fi
    done
    echo -ne "${line_out}\n"
}

_o_write_n_x_times(){
    # how it works
    # 1 - ts gets as many spaces as $1 is long
    # 2 - every space is expanded to $2 and and written
    local ts
    printf -v ts "%${1}s"
    printf %s "${ts// /$2}"
}

_o_write_n_x_times_newline(){
    local ts
    printf -v ts "%${1}s"
    printf '%s\n' "${ts// /$2}"
}

_o_write_n_x_times_newlines(){
    local i; for ((i=0; i<$1; i++)); { printf "%s\n" "$2"; };
}

_o_del_word(){
    cnt=0
    max=${#1}
    while (( cnt < max )); do
        echo -n -e "\b \b"
        (( cnt++ ))
    done
}

_o_spin_cmd(){
    {
        while :; do
            for a in / - \\ \|; do
                printf '%s\b' "$a";
                sleep 0.1;
            done;
        done &
    } 2> /dev/null
    local spin_pid=$!

    "$@"
    local status=$?

    { kill $spin_pid && wait; } 2>/dev/null

    return $status
}

export -f _o_symbol_section _o_section _o_echo_padd _o_echo_long
export -f _o_del_word _o_write_n_x_times _o_write_n_x_times_newline
export -f _o_spin_cmd
### formatted output - end #######################################}}}

### debug ########################################################{{{
export OBI_DEBUG=5
export OBI_DEBUG_ACTION='sleep'
_o_debug(){
    #
    # This function displays debug information
    # when the debug level set via command line
    # is greater or equal the level passed to
    # the function
    #
    # In:
    # $1 - level
    # $2 - message
    #

    local level="$1"
    shift

    msg="$@"

    if (( level <= $OBI_DEBUG )); then
        while read -r debug_line <&13; do
            printf '%s\n' "$_yellow#-DEBUG$level-# :$_reset $debug_line" 1>&2
        done 13<<< "$msg"
    else
        return 1
    fi
}

_o_debug_action(){
    #
    # This function displays debug information
    # when the debug level set via command line
    # is greater or equal the level passed to
    # the function
    #
    # In:
    # $1 - level
    # $2 - message
    #

    local level="$1"
    local action="${2:-$OBI_DEBUG_ACTION}"
    shift 2

    if _o_debug "$level" "$@"; then
        [[ "$OBI_DEBUG_ACTION" == "sleep" ]] && sleep 5
        [[ "$OBI_DEBUG_ACTION" == "prompt" ]]   && read -p "press key to continue" -n 1
        return 0
    else
        return 1
    fi
}

export _o_debug_ _o_debug_action
### debug end ####################################################}}}


### error ########################################################{{{
export OBI_ERROR_ACTION='ask'

_o_say() { echo "${_white}${OBI_PREFIX:-""}$@${_reset}"; }
_o_err(){ echo; echo -n "${_bold}${_red}Error: "; _o_say "$@"; echo -n "${_reset}"; }
_o_success(){ echo; echo -n "${_bold}${_green}Success: "; _o_say "$@"; echo -n "${_reset}"; }

#fatal error
_o_ferr(){ _o_err "$@"; return 1; }
_o_ferrx(){ _o_err "$@"; exit 1; }

#non fatal error
_o_nerr(){
_o_err "$@"
case $OBI_ERROR_ACTION in
    exit) return 1 ;;
    ask)  local rv="$(_o_ask_yn "The Program encountered an error - do you want to continue?")"; [[ "$rv" == "no" ]] && exit 1 ;;
esac
}

_o_nerrx(){
_o_err "$@"
case $OBI_ERROR_ACTION in
    exit) exit 1 ;;
    ask)  local rv="$(_o_ask_yn "The Program encountered an error - do you want to continue?")"; [[ "$rv" == "no" ]] && exit 1 ;;
esac
}

# ask to continue on error
_o_ask_yn(){
while true; do
    read -p "$@ (y/n) " yn
    case "$yn" in
        [Yy]*) return 0 ;;
        [Nn]*) return 1 ;;
        *) echo "Please answer with yes or no." 1>&2 ;;
    esac
done
}

_o_ask_to_contx(){
    _o_ask_yn || return 1
}


export -f _o_say _o_success _o_err _o_nerr _o_ferr _o_ask_yn
export -f _o_ferrx _o_ask_to_contx
### error - end ##################################################}}}

### execute commands #############################################{{{

_o_execute_show(){
    _o_symbol_section "="
    echo "running: $@"
    _o_symbol_section "#" " external programm => "
    "$@"
    _o_symbol_section "#" " <= external programm "
}

_o_ignore(){
    "$@"
    return 0
}

_o_check_cmd(){
    command -v "$1" > /dev/null 2>&1
    return $?
}

_o_need_cmd(){
    if ! _o_fcheck_cmd "$1"; then
        _o_ferr "need '$1' (command not found)"
        return 1
    fi
}

_o_need_ok(){
    rv=$?
    if (( $rv != 0 )); then
        _o_ferr "$1"
        return $rv
    fi
}
_o_need_okx() { _need_ok "$@" || exit $?; }

_o_assert(){
    if [[ $1 -ne 0 ]]; then
        _o_ferr "(assert got '$1' expected '0') - $2 "
        return $?
    fi
}
_o_assertx() { _o_assert "$@" || exit $?; }

# $(( )) expression return 0 for fail
_o_assert_calc(){
    if [[ $1 -eq 0 ]]; then
        _o_ferr "(assert - got '$1' expected not '0') - $2 "
        return $?
    fi
}
_o_assert_calcx() { _o_assert_calc "$@" || exit $?; }

_o_assert_nz(){
    if [[ -z "$1" ]]; then
        _o_ferr "(assert '$1' is empty) - $2"
        return $?
    fi
}
_o_assert_nzx() { _o_assert_nz "$@" || exit $?; }

_o_ensure(){
    "$@"
    _o_need_ok "command failed: $*"
    return $?
}
_o_ensurex() { _ensure "$@" || exit $?; }

_o_execute_bash(){
    bash -c "$*"
    return $?
}

export -f _o_execute_show _o_ignore _o_check_cmd _o_need_cmd
export -f _o_need_ok  _o_assert _o_assert_nz  _o_ensure
export -f _o_need_okx _o_assertx _o_assert_nzx _o_ensurex
export -f _o_execute_bash
### execute - end ################################################}}}

### file commands ################################################{{{
_o_file_parts(){
    _o__full_path="$(readlink -f "$1")"
    _o__path="$_o__full_path"
    _o__dir="${_o__full_path%/*}"
    _o__name_full="${_o__full_path##*/}"
    _o__name="${_o__name_full%.*}"
    _o__name_ext="${_o__name_full##*.}"
}

_o_wait_for_file_event(){
    # cmd dir command arg1 arg2
    # events must be uppper-case
    (
        _o_assert_nz "${2:-""}" "usage: watchdir <directory> <command> [arg ...]"

        local dir="$1"
        shift
        while inotifywait --exclude '/\..+' -e MODIFY -e CLOSE_WRITE -r "${dir}"; do
            echo "### inotifywait exec - start #######################"
            echo "command: $*"
            sleep 0.1
            "$@"
            echo
            echo "### inotifywait exec - end #########################"
        done
    )
}

_o_wait_for_file_event_bash(){
    (
        _o_assert_calcx "$(( $# > 1 ))" "usage: watchdir <directory> '<bash; commands>'"
        local dir="$1"
        shift
        set -m
        while inotifywait --exclude '/\..+' -e MODIFY -e CLOSE_WRITE -r "${dir}"; do
            echo "### inotifywait exec #########################"
            echo "command: $@"
            sleep 0.1
            _o_execute_bash "$@"
            echo "### inotifywait exec #########################"
        done
    )
}

export -f _o_wait_for_file_event _o_wait_for_file_event_bash
### file commands - end ##########################################{{{


### system info ##################################################{{{
_o__page_size_bytes="$(getconf PAGESIZE)"
_o__page_size_KiB="$((_o__page_size_bytes / 1024))"

_o_get_meminfo_statm(){
    #most reliable
    local size="$( awk '{print $1}' < /proc/$1/statm )"
    local resident="$( awk '{print $2}' < /proc/$1/statm )"
    local shared="$( awk '{print $3}' < /proc/$1/statm )"
    echo "VmSize_KiB $((size * _o__page_size_KiB)) VmRss_KiB $((resident * _o__page_size_KiB)) RssFile+RssShmem_KiB $((shared * _o__page_size_KiB))"
}

_o_get_meminfo_top(){
    #slow
    local line="$(top -p $1 -n1 -b | tail -n1 )"
    local VIRT="$( awk '{print $5}' <<< "$line" )"
    local RES="$( awk '{print $6}' <<< "$line" )"
    local SHR="$( awk '{print $7}' <<< "$line" )"
    echo "VmSize $VIRT VmRss $RES SHR $SHR (no fixed units)"
}

_o_get_meminfo_ps(){
    local line="$(ps -p$1 -o rss,vsz | tail -n1)"
    local RSS="$( awk '{print $1}' <<< "$line" )"
    local VSZ="$( awk '{print $2}' <<< "$line" )"
    echo "VmSize_KiB $VSZ VmRss_kB $RSS"
    # KiB though manpage claims other wise"
}


_o_get_meminfo_stat(){
    local vsize="$( awk '{print $23}' < /proc/$1/stat )"
    local rss="$( awk '{print $24}' < /proc/$1/stat )"
    echo "VmSize_KiB $(( vsize / 1024 )) VmRss_KiB $(( rss * _o__page_size_KiB ))"
}

_o_get_meminfo_status(){
	local VmSize="$(grep VmSize /proc/$1/status | awk '{print $2}'  )"
	local VmRSS="$(grep VmRSS /proc/$1/status | awk '{print $2}'  )"
	echo "VmSize_KiB $VmSize VmRss_KiB $VmRSS"
    # claims kB
}
### system info - end ############################################}}}


### remote commands ##############################################{{{
_o_execute_remote(){
    local interpreter="$1"
    local user_at_host="$2"
    local realscript="$3"
    shift 3

    local -a args

    local count=0
    for arg in "$@"; do
      args[count]=$(printf '%q' "$arg")
      ((count++))
    done

    ssh "$user_at_host" "cat | ${interpreter} /dev/stdin" "${args[@]}" < "$realscript"
}
export -f _o_execute_remote
### remote commands - end ########################################}}}


### array ########################################################{{{
#http://stackoverflow.com/questions/7442417/how-to-sort-an-array-in-bash
declare BSORT=()
_o_bubble_sort(){
    # @param [ARGUMENTS]...
    #
    # Sort all positional arguments and store them in global array BSORT.
    # Without arguments sort this array. Return the number of iterations made.
    #
    # Bubble sorting lets the heaviest element sink to the bottom.
    #
    # @usage
    #
    # BSORT=(a c b 'z y' 3 5)
    # bubble_sort
    # echo ${BSORT[@]}
    (($# > 0)) && BSORT=("$@")
    local j=0 ubound=$((${#BSORT[*]} - 1))
    while ((ubound > 0))
    do
        local i=0
        while ((i < ubound))
        do
            if [ "${BSORT[$i]}" \> "${BSORT[$((i + 1))]}" ]
            then
                local t="${BSORT[$i]}"
                BSORT[$i]="${BSORT[$((i + 1))]}"
                BSORT[$((i + 1))]="$t"
            fi
            ((++i))
        done
        ((++j))
        ((--ubound))
    done
    #echo $j
}

_o_sort(){
    local arr=( "$@" )
    _o_bubble_sort "${arr[@]}"
}

_o_sort_echo(){
    local arr=( "$@" )
    _o_sort "${arr[@]}"
    echo ${BSORT[@]}
}

_o_get_last(){
    local arr=( "$@" )
    echo "${arr[${#arr[@]}-1]}"
}

_o_sort_get_last(){
    local arr=( "$@" )
    _o_bubble_sort "${arr[@]}"
    echo "${BSORT[${#BSORT[@]}-1]}"
}

export BSORT
export -f _o_bubble_sort _o_sort _o_sort_echo _o_get_last _o_sort_get_last
### array - end ##################################################}}}
export OBI_BASH_LIB_SOURCED=true
